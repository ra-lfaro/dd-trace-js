'use strict'

const { expect } = require('chai')
const proxyquire = require('proxyquire')

describe('vulnerability-analyzer', () => {
  const VULNERABLE_VALUE = 'VULNERABLE_VALUE'
  const VULNERABILITY = 'VULNERABILITY'
  const VULNERABILITY_LOCATION = 'VULNERABILITY_LOCATION'
  const ANALYZER_TYPE = 'TEST_ANALYZER'
  const SPAN_ID = '123456'

  let VulnerabilityAnalyzer
  let vulnerabilityReporter
  let overheadController
  let pathLine
  let iastContextHandler
  let iastPlugin
  let datadogCore
  beforeEach(() => {
    vulnerabilityReporter = {
      createVulnerability: sinon.stub().returns(VULNERABILITY),
      addVulnerability: sinon.stub()
    }
    pathLine = {
      getFirstNonDDPathAndLine: sinon.stub().returns(VULNERABILITY_LOCATION)
    }
    overheadController = {
      hasQuota: sinon.stub()
    }
    iastContextHandler = {
      getIastContext: sinon.stub()
    }
    datadogCore = {
      storage: {
        getStore: sinon.stub()
      }
    }
    iastPlugin = proxyquire('../../../../src/appsec/iast/iast-plugin', {
      './iast-context': iastContextHandler,
      '../../../../datadog-core': datadogCore
    })
    VulnerabilityAnalyzer = proxyquire('../../../../src/appsec/iast/analyzers/vulnerability-analyzer', {
      '../vulnerability-reporter': vulnerabilityReporter,
      '../path-line': pathLine,
      '../overhead-controller': overheadController,
      '../iast-plugin': iastPlugin
    })
  })
  afterEach(() => {
    sinon.restore()
  })

  const shouldReportCasesData = [
    {
      iastPluginContext: {
        store: {},
        iastContext: {}
      },
      oceResult: true,
      isVulnerable: true,
      reported: true
    },
    {
      iastPluginContext: {
        store: {},
        iastContext: {}
      },
      oceResult: false,
      isVulnerable: false,
      reported: false
    },
    {
      iastPluginContext: {
        store: {},
        iastContext: {}
      },
      oceResult: false,
      isVulnerable: true,
      reported: false
    },
    {
      iastPluginContext: {
        store: {},
        iastContext: {}
      },
      oceResult: true,
      isVulnerable: false,
      reported: false
    },
    {
      iastPluginContext: {
        store: undefined,
        iastContext: undefined
      },
      oceResult: true,
      isVulnerable: true,
      reported: true
    }
  ]
  shouldReportCasesData.forEach((shouldReportCaseData) => {
    it(`should ${shouldReportCaseData.reported ? 'report' : 'not report'} vulnerability
    when value is ${shouldReportCaseData.isVulnerable ? 'vulnerable' : 'not vulnerable'},
    OCE ${shouldReportCaseData.oceResult ? 'allows' : 'rejects'} the operation
    and iastContext is ${shouldReportCaseData.iastPluginContext.iastContext ? 'provided' : 'not provided'}`, () => {
      const vulnerabilityAnalyzer = new VulnerabilityAnalyzer(ANALYZER_TYPE)
      overheadController.hasQuota.returns(shouldReportCaseData.oceResult)
      iastContextHandler.getIastContext.returns(shouldReportCaseData.iastPluginContext.iastContext)
      sinon.stub(vulnerabilityAnalyzer, '_isVulnerable').returns(shouldReportCaseData.isVulnerable)
      sinon.stub(vulnerabilityAnalyzer, '_report')
      vulnerabilityAnalyzer.analyze(VULNERABLE_VALUE, shouldReportCaseData.iastPluginContext)
      if (shouldReportCaseData.reported) {
        expect(vulnerabilityAnalyzer._report).to.have.been.calledOnce
      } else {
        expect(vulnerabilityAnalyzer._report).not.to.be.called
      }
    })
  })

  it('should return not vulnerable if not override', () => {
    const vulnerabilityAnalyzer = new VulnerabilityAnalyzer(ANALYZER_TYPE)
    const isVulnerable = vulnerabilityAnalyzer._isVulnerable()
    expect(isVulnerable).to.be.false
  })

  it('should create vulnerability to reporter when reporting', () => {
    const vulnerabilityAnalyzer = new VulnerabilityAnalyzer(ANALYZER_TYPE)
    const context = {
      rootSpan: {
        context: sinon.mock().returns({
          toSpanId: sinon.mock().returns(SPAN_ID)
        })
      }
    }
    vulnerabilityAnalyzer._report(VULNERABLE_VALUE, context)
    expect(vulnerabilityReporter.createVulnerability).to.have.been.calledOnceWithExactly(
      ANALYZER_TYPE,
      { value: VULNERABLE_VALUE },
      SPAN_ID,
      VULNERABILITY_LOCATION
    )
  })

  it('should add vulnerability to reporter when reporting', () => {
    const vulnerabilityAnalyzer = new VulnerabilityAnalyzer(ANALYZER_TYPE)
    const context = {
      rootSpan: {
        context: sinon.mock().returns({
          toSpanId: sinon.mock().returns(SPAN_ID)
        })
      }
    }
    vulnerabilityAnalyzer._report(VULNERABLE_VALUE, context)
    expect(vulnerabilityReporter.addVulnerability).to.have.been.calledOnceWithExactly(
      context,
      VULNERABILITY
    )
  })

  it('should wrap subscription handler and catch thrown Errors', () => {
    const vulnerabilityAnalyzer = new VulnerabilityAnalyzer(ANALYZER_TYPE)
    const handler = sinon.spy(() => {
      throw new Error('handler Error')
    })
    const wrapped = vulnerabilityAnalyzer._wrapHandler(handler)

    const iastContext = {
      name: 'test'
    }
    iastContextHandler.getIastContext.returns(iastContext)

    const store = {}
    datadogCore.storage.getStore.returns(store)

    expect(typeof wrapped).to.be.equal('function')
    const message = {}
    const name = 'test'
    expect(() => wrapped(message, name)).to.not.throw()
    const args = handler.getCall(0).args
    expect(args[0]).to.be.eq(message)
    expect(args[1].iastContext).to.be.eq(iastContext)
    expect(args[1].store).to.be.eq(store)
    expect(args[2]).to.be.eq(name)
  })

  it('should catch thrown Errors inside subscription handlers', () => {
    const vulnerabilityAnalyzer = new VulnerabilityAnalyzer(ANALYZER_TYPE)
    vulnerabilityAnalyzer.addSub({ channelName: 'dd-trace:test:error:sub' }, () => {
      throw new Error('handler Error')
    })

    expect(vulnerabilityAnalyzer._subscriptions).to.have.lengthOf(1)
    vulnerabilityAnalyzer._subscriptions[0].enable()

    const dc = require('diagnostics_channel')
    expect(() => { dc.channel('dd-trace:test:error:sub').publish({}) }).to.not.throw()
  })
})
